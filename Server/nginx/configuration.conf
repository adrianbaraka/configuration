# for all

limit_req zone=one burst=5 nodelay;
# zone=one: Applies the rate limiting defined in the "one" zone.
# burst=5: Allows a client to make up to 5 requests above the defined rate in a short burst. Excess requests are delayed.
# nodelay: Excess requests are rejected immediately without delay.


# Serving static files
server {
    listen 80;
    server_name example.com www.example.com;

    #look for 
    root /var/www/example.com/html;
    index index.html index.htm;

    # no need for this it does automatically
    #[

    #Looks in this order
    #$uri: The exact requested URI (e.g., /about.html).
    #$uri/: The requested URI as a directory (e.g., /blog/). If found, Nginx will look for the index file within that directory.
    #/index.html: As a fallback, serve the index.html file. This is often used for single-page applications (SPAs) where client-side routing handles different paths.
    # with this no need to specify other location blocks
    #location / {
    #    try_files $uri $uri/ /index.html;
    #}

    #]

    # Serve static files efficiently
    location ~* \.(?:css|js|gif|jpg|jpeg|png|ico|svg|woff|woff2|ttf|eot|mp4|webm|ogg)$ {
        # caches the files in the regex for specified days (30d)
        expires 30d;
        #  Disables access logging for these static files
        access_log off;
        #  Sets the Cache-Control header, providing more explicit caching instructions to the browser (caching 30days in seconds)
        add_header Cache-Control "public, max-age=2592000";
    }

    # Prevent access to dotfiles (.htaccess, .git, etc.)
    location ~ /\. {
        deny all;
        access_log off;
        log_not_found off;
    }

    #Enable gzip compression for text-based content
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_buffers 16 8k;
    gzip_http_version 1.1;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/rss+xml application/atom+xml image/svg+xml;



}


# as a reverse proxy
server {
    listen 80;
    server_name proxy.example.com;

    location / {
        proxy_pass http://backend.example.com:8080;

        #Passes the original Host header from the client request to the backend server.
        proxy_set_header Host $host;

        #Sends the client's actual IP address to the backend server in the X-Real-IP header.
        proxy_set_header X-Real-IP $remote_addr;

        # Appends the IP address of the proxy server to the X-Forwarded-For header. 
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        #Passes the original protocol used by the client (HTTP or HTTPS) to the backend server in the X-Forwarded-Proto header. 
        proxy_set_header X-Forwarded-Proto $scheme;

        # Adjust timeouts
        proxy_connect_timeout       5s;
        proxy_send_timeout          60s;
        proxy_read_timeout          60s;

        # Buffer settings (can be helpful for slow clients or large responses)
        proxy_buffering           on;
        proxy_buffers             8 32k;
        proxy_buffer_size         64k;
        proxy_max_temp_file_size  2048m;

        # Handling redirects from the backend
        proxy_redirect off;
        
    }
}

# To act as a load balancer

#Define the servers here like so then conf is the same as a proxy only difference is proxy_pass http://backend_servers

upstream backend_servers {
    # a higher weight means this server will receive more requests.
    server backend1.example.com:8080 weight=5;
    server backend2.example.com:8080 weight=3;
    server backend3.example.com:8080 backup; # This server will only be used if others fail
    server backend3.example.com:8080 down;

    #down: This directive explicitly marks a server as permanently unavailable. When you see down in the configuration.
    #backup: This directive clearly designates a server as a backup server. It will only receive traffic when all the primary (non-backup) servers in the upstream block are considered unavailable (due to health checks or other failures).

    # Optional load balancing methods (default is round-robin)
    # least_conn;  Directs requests to the server with the fewest active connections.
    # ip_hash;   Distributes requests based on the client's IP address. This ensures that requests from the same client are always directed to the same backend server
    # random;
}

    location / {
        proxy_pass http://backend_servers;
    }



# using HTTPS port 443 

#redirect from http to https
server {
    listen 80;
    server_name domain.example.com;

    # Redirect all HTTP requests to HTTPS
    return 301 https://$host$request_uri;
}

#configuring listening on port 443
server {
    listen 443 ssl http2; # Listen on port 443 for HTTPS, enable HTTP/2 if supported
    server_name loadbalancer.example.com;

    ssl_certificate /etc/nginx/ssl/your_domain.crt; #path to SSL certificate file
    ssl_certificate_key /etc/nginx/ssl/your_domain.key; # path to  SSL private key file

    ssl_protocols TLSv1.2 TLSv1.3; # Recommended SSL/TLS protocols
    ssl_prefer_server_ciphers on;
    ssl_ciphers 'ECDHE+AESGCM:CHACHA20'; # Modern and secure cipher suites

    # Optional: Enable HSTS (HTTP Strict Transport Security)
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # Optional: Configure OCSP stapling for better performance Read more
    ssl_stapling on;
    ssl_stapling_verify on;
    resolver 8.8.8.8 8.8.4.4 valid=300s; # Use Google's public DNS servers
    resolver_timeout 5s;
    #if using proxy
    proxy_set_header X-Forwarded-Proto https; # Indicate to the backend that the request came over HTTPS

}


#To change the default error files
    error_page 404 /404.html;
    error_page 403 /403.html;

    error_page 500 502 503 504 /50x.html;

    location /simulate_503 {
    return 503;
    }   


    #set it to internal prevents these locations from being directly accessed by external clients for security
    location = /404.html {
        internal;
    }

    location = /403.html {
        internal;
    }

    location = /50x.html {
        internal;
    }
